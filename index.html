<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Persist Event Cursor Widget</title>
</head>
<body>
  <!--
    Invisible widget that:
      â€¢ Watches your Event table selection
      â€¢ Persists it in sessionStorage
      â€¢ Restores it on every page load
      â€¢ Drives the document cursor (allowSelectBy: true)
  -->

  <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>
  <script>
    // 1) Initialize as a linking widget:
    //    - no permission prompts (none)
    //    - map only the 'id' column
    //    - allowSelectBy: true enables global cursor control
    grist.ready({
      requiredAccess: 'none',
      columns: ['id'],
      allowSelectBy: true
    });

    const STORAGE_KEY = 'persist_cursor_Event';

    // 2) Restore logic: read last-saved cursor and move it globally
    async function restoreCursor() {
      const stored = sessionStorage.getItem(STORAGE_KEY);
      if (!stored) { return; }
      try {
        const {tableId, rowId, colId} = JSON.parse(stored);
        // This now drives the document-level cursor
        await grist.setCursorPos({tableId, rowId, colId});
        console.log('âœ… Restored global cursor to', tableId, rowId, colId);
      } catch (err) {
        console.warn('âš ï¸ Failed to restore cursor:', err);
      }
    }

    let didRestore = false;

    // 3) onRecord fires once immediately (with the current selection)
    //    and again whenever the selection changes.
    //    We use the *first* call to restoreCursor, then always store.
    grist.onRecord((record) => {
      if (!didRestore) {
        restoreCursor();
        didRestore = true;
      }
      if (record && record.id != null) {
        // Save the full cursor position for Event.id
        const cursor = {
          tableId: 'Event',
          rowId: record.id,
          colId: 'id'
        };
        sessionStorage.setItem(STORAGE_KEY, JSON.stringify(cursor));
        console.log('ðŸ’¾ Stored Event cursor:', cursor);
      }
    });
  </script>
</body>
</html>
